import 'package:dart_frog/dart_frog.dart';
import 'package:bcrypt/bcrypt.dart';
import 'dart:convert';
import '../../database.dart'; // Note le chemin relatif

Future<Response> onRequest(RequestContext context) async {
  if (context.request.method == HttpMethod.post) {
    final body = await context.request.body();
    final data = jsonDecode(body);

    final fullName = data['fullname'];
    final email = data['email'];
    final password = data['password'];
    final confirmPassword = data['confirm-password'];

    if (fullName == null || email == null || password == null || confirmPassword == null) {
      return Response.json(
        statusCode: 400,
        body: {'message': 'Tous les champs sont requis.'},
      );
    }

    if (password != confirmPassword) {
      return Response.json(
        statusCode: 400,
        body: {'message': 'Les mots de passe ne correspondent pas.'},
      );
    }

    // Vérifie si l'email est déjà utilisé
    final result = await db.query(
      'SELECT * FROM users WHERE email = @email',
      substitutionValues: {'email': email},
    );

    if (result.isNotEmpty) {
      return Response.json(
        statusCode: 409,
        body: {'message': 'Cet email est déjà utilisé.'},
      );
    }

    // Hash le mot de passe
    final hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());

    // Insert user dans PostgreSQL
    await db.query(
      'INSERT INTO users (full_name, email, password) VALUES (@fullName, @email, @password)',
      substitutionValues: {
        'fullName': fullName,
        'email': email,
        'password': hashedPassword,
      },
    );

    return Response.json(
      statusCode: 201,
      body: {'message': 'Utilisateur inscrit avec succès.'},
    );
  }

  return Response.json(
    statusCode: 405,
    body: {'message': 'Méthode non autorisée.'},
  );
}